// Introduction to smart contracts from solidity docs

// Introduction to smart contracts 
// https://docs.soliditylang.org/en/develop/introduction-to-smart-contracts.html

// Subcurrency Example
// following contract implements simplest form of cryptocurrency
// - contract allows only its creator to create new coins (different issuance schemes are possible) 
// - anyone can send coins to each other without need for registering with username and password, 
// all you need is Ethereum keypair

// -------------------------------------------------------------------------------------------------
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.4;

contract Coin {
    // The keyword "public" makes variables
    // accessible from other contracts
    address public minter;
    mapping(address => uint) public balances;

    // Events allow clients to react to specific
    // contract changes you declare
    event Sent(address from, address to, uint amount);

    // Constructor code is only run when the contract
    // is created
    constructor() {
        minter = msg.sender;
    }

    // Sends an amount of newly created coins to an address
    // Can only be called by the contract creator
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        balances[receiver] += amount;
    }

    // Errors allow you to provide information about
    // why an operation failed. They are returned
    // to the caller of the function.
    error InsufficientBalance(uint requested, uint available);

    // Sends an amount of existing coins
    // from any caller to an address
    function send(address receiver, uint amount) public {
        if (amount > balances[msg.sender])
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });

        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}

// -------------------------------------------------------------------------------------------------
line address public minter; 
- declares state variable of type address
- address type is a 160-bit value that does not allow any arithmetic operations
- suitable for storing addresses of contracts, or hash of public half of keypair belonging to external accounts
- keyword public automatically generates function that allows you to access current 
value of state variable from outside of contract 
- without this keyword, other contracts have no way to access variable
- code of function generated by compiler is equivalent to following 
(ignore external and view for now):
function minter() external view returns (address) { return minter; }
- you could add function like above yourself, but you would have function and state variable with same name
- there is no need to do this, compiler figures it out for you

next line, mapping(address => uint) public balances; 
- also creates a public state variable, but it is a more complex datatype
- mapping type maps addresses to unsigned integers
- mappings can be seen as hash tables which are virtually initialised such that every possible key
exists from start and is mapped to value whose byte-representation is all zeros
- however, it is neither possible to obtain list of all keys of mapping, nor list of all values. 
- record what you added to mapping, or use it in context where this is not needed 
- rr even better, keep list, or use more suitable data type

function balances(address account) external view returns (uint) {
    return balances[account];
}
- you can use this function to query balance of single account

- line event Sent(address from, address to, uint amount); 
- declares “event”, which is emitted in last line of function send
- to listen for this event, you could use following JavaScript code, which uses web3.js to create Coin contract object, 
and any user interface calls automatically generated balances function from above:

Coin.Sent().watch({}, '', function(error, result) {
    if (!error) {
        console.log("Coin transfer: " + result.args.amount +
            " coins were sent from " + result.args.from +
            " to " + result.args.to + ".");
        console.log("Balances now:\n" +
            "Sender: " + Coin.balances.call(result.args.from) +
            "Receiver: " + Coin.balances.call(result.args.to));
    }
})
- constructor is special function that  address of the person creating the contract. 
- msg variable (together with tx and block) is special global variable that contains 
properties which allow access to blockchain
msg.sender is always address where current (external) function call came from

- functions that make up contract, and that users and contracts can call are mint and send

- Errors allow you to provide more information to caller about why condition or operation failed
Errors are used together with revert statement
- revert statement unconditionally aborts and reverts all changes similar to require function, 
but it also allows you to provide name of error and additional data which will be supplied to caller
(and eventually to the front-end application or block explorer) 
so that failure can more easily be debugged or reacted upon

- send function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the if condition evaluates to true. As a result, the revert will cause the operation to fail while providing the sender with error details using the InsufficientBalance error.




